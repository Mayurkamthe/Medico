package com.medico.service;

import com.medico.entity.AIAnalysisResult;
import com.medico.entity.Patient;
import com.medico.entity.VitalReading;
import com.medico.repository.AIAnalysisResultRepository;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Service for integrating with Gemini AI for clinical decision support.
 * AI outputs are labeled as "AI-assisted clinical insights" and NEVER provide
 * final diagnosis.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class GeminiAIService {

    private final AIAnalysisResultRepository aiAnalysisResultRepository;
    private final ObjectMapper objectMapper;
    private final WebClient.Builder webClientBuilder;

    @Value("${app.gemini.api-key}")
    private String apiKey;

    @Value("${app.gemini.api-url}")
    private String apiUrl;

    private static final String DISCLAIMER = "⚠️ AI-Assisted Clinical Insight: This analysis is generated by AI and should NOT be used as a final diagnosis. Always apply clinical judgment and consider patient history.";

    private static final String PROMPT_TEMPLATE = """
            You are a medical AI assistant providing clinical decision support for a doctor.
            Based on the following patient vitals, suggest POSSIBLE conditions that the doctor should consider.

            Patient Vitals:
            - Heart Rate: %d BPM
            - SpO2: %d%%
            - Body Temperature: %.1f°C

            Additional context: %s

            Respond ONLY in valid JSON format with this exact structure:
            {
              "possible_conditions": ["condition1", "condition2", "condition3"],
              "severity": "LOW|MODERATE|HIGH|CRITICAL",
              "recommendation": "Brief clinical recommendation for the doctor",
              "disclaimer": "This is AI-assisted clinical insight only. Not a diagnosis."
            }

            CRITICAL RULES:
            1. Do NOT provide a final diagnosis
            2. Only suggest POSSIBLE conditions for the doctor to investigate
            3. Always recommend consulting with the patient and reviewing medical history
            4. Keep recommendations brief and actionable
            5. The severity should match the vitals severity level
            """;

    /**
     * Analyze patient vitals using Gemini AI and store results.
     */
    public AIAnalysisResult analyzeVitals(Patient patient, VitalReading vitalReading) {
        try {
            String prompt = String.format(PROMPT_TEMPLATE,
                    vitalReading.getHeartRate(),
                    vitalReading.getSpo2(),
                    vitalReading.getTemperature(),
                    patient.getMedicalHistory() != null ? patient.getMedicalHistory()
                            : "No prior medical history available");

            String response = callGeminiAPI(prompt);

            if (response == null || response.isEmpty()) {
                log.error("Empty response from Gemini API");
                return createFallbackAnalysis(patient, vitalReading);
            }

            return parseAndSaveAnalysis(patient, vitalReading, response);

        } catch (Exception e) {
            log.error("Error analyzing vitals with Gemini AI", e);
            return createFallbackAnalysis(patient, vitalReading);
        }
    }

    private String callGeminiAPI(String prompt) {
        try {
            WebClient webClient = webClientBuilder.build();

            Map<String, Object> content = new HashMap<>();
            content.put("parts", List.of(Map.of("text", prompt)));

            Map<String, Object> requestBody = new HashMap<>();
            requestBody.put("contents", List.of(content));

            // Add generation config for JSON output
            Map<String, Object> generationConfig = new HashMap<>();
            generationConfig.put("temperature", 0.3);
            generationConfig.put("maxOutputTokens", 1024);
            requestBody.put("generationConfig", generationConfig);

            String fullUrl = apiUrl + "?key=" + apiKey;

            return webClient.post()
                    .uri(fullUrl)
                    .contentType(MediaType.APPLICATION_JSON)
                    .bodyValue(requestBody)
                    .retrieve()
                    .bodyToMono(String.class)
                    .onErrorResume(e -> {
                        log.error("Gemini API call failed", e);
                        return Mono.empty();
                    })
                    .block();

        } catch (Exception e) {
            log.error("Failed to call Gemini API", e);
            return null;
        }
    }

    private AIAnalysisResult parseAndSaveAnalysis(Patient patient, VitalReading vitalReading, String apiResponse) {
        try {
            JsonNode root = objectMapper.readTree(apiResponse);

            // Extract the text content from Gemini response
            String textContent = root
                    .path("candidates")
                    .path(0)
                    .path("content")
                    .path("parts")
                    .path(0)
                    .path("text")
                    .asText();

            // Clean up the response - remove markdown code blocks if present
            textContent = textContent.replaceAll("```json\\s*", "").replaceAll("```\\s*", "").trim();

            // Parse the JSON content
            JsonNode analysisJson = objectMapper.readTree(textContent);

            String possibleConditions = analysisJson.path("possible_conditions").toString();
            String severity = analysisJson.path("severity").asText("HIGH");
            String recommendation = analysisJson.path("recommendation").asText("Further evaluation recommended");

            AIAnalysisResult result = AIAnalysisResult.builder()
                    .patient(patient)
                    .vitalReading(vitalReading)
                    .possibleConditions(possibleConditions)
                    .severity(severity)
                    .recommendation(recommendation)
                    .disclaimer(DISCLAIMER)
                    .build();

            return aiAnalysisResultRepository.save(result);

        } catch (Exception e) {
            log.error("Failed to parse Gemini API response", e);
            return createFallbackAnalysis(patient, vitalReading);
        }
    }

    private AIAnalysisResult createFallbackAnalysis(Patient patient, VitalReading vitalReading) {
        AIAnalysisResult result = AIAnalysisResult.builder()
                .patient(patient)
                .vitalReading(vitalReading)
                .possibleConditions("[\"Unable to generate AI analysis\", \"Manual review required\"]")
                .severity("HIGH")
                .recommendation("AI analysis unavailable. Please conduct manual assessment of patient vitals.")
                .disclaimer(DISCLAIMER)
                .build();

        return aiAnalysisResultRepository.save(result);
    }
}
